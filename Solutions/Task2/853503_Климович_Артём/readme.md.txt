Python 3.7.7

В прикреплении находится архив, который демонстрирует работоспособность созданного нами пакета и самой лабораторной работы.
В начале нужно распаковать архив и перейти в папку проекта.Далее прописываем в терминале python setup.py install. После этого мы можем перейти в модуль main.py
в котором продемонстрированы задания лабараторной работы. 
Все модули, кроме setup.py, находятся в каталоге projec.

Таблица соответсвия задания и названия програмы с их тестами:

Задание       Название           Тест             Доп.Файлы

Основное 1    Sort               test_sort        numbers,tmpo3zedh7c -неотсортированный и отсортированный файл соответсвенно.

Основное 2,
Доп. 1        JSON               test_json
  
Основное 3    Vector             test_vector

Основное 4    Fibonacci          test_Fibonacci

Основное 5    Тесты всех основных

Доп. 2        Singleton

Доп. 3        setup.py(Находится в корне проекта)


Пояснение к выполненым заданиям.

Основное 1. В программе мы разделяем исходный неотсортированный файл на n-ое количество врменных файлов. 
n зависит от того, сколько чисел мы будем вносить в каждый файл. Этот процесс происходит путем считывания 
m чисел из исходного файла в кортеж. После происходит сортировка кортежа и последующая запись этого кортежа во
временный файл. С целью увеличения скорости была использована быстрая сортировка. Название временных файлов мы 
храним в кортеже.Для демонстрации того, что программа работает, при каждом создании временного файла выводится 
его порядковый номер 
После получения n отсортированных файлов происходит их объединение. В целях ускорения процеса можно было 
использовать кучу, но она была запрещена к использованию нашим лектором. Из-за этого, был выбран способ слияния файлов
путем сравнения их первых элементов. Функция слияния файлов принимает в себя k файлов и выдает 1 файл состоящий 
из k файлов.Процесс слияния файлов происходит до того момента, пока не останется всего 1 итоговый файл.

Тест 1
Покрытие програмы 100%. Рассматривается 2 случая:
- полного удаления всех временных файлов, кроме отсортированного 
- проверка того, что файл отсортирован верно

Основное 2 + Доп. 1. В программе мы реализуем сразу два перевода: в JSON и обратно. Для перевода в JSON была написана 
функция, которая проверяет тип поступивших данных и, в зависимости от этого, проводит далнейшие преобразование. 
Если мы встречаем список,кортеж и т.п, то мы делаем перебор их значений, вызывая рекрсивно функцию перевода с полученными из них данными.
Если же текстовые или числовые данные, то мы возвращаем их обратно в двойных кавычках.
Если же некоторый класс, то приводем его к виду словоря, и рекурсивно вызывая функцию перевода передаем туда словарь. 
Обратное преобразование проходит сложнее. При встрече скобки, мы рекурсивно вызываем функцию перевода из JSON, передав в 
нее остаток исходной строки.При встрече закрывающей скобки, мы возвращаемся из рекурсивно вызванной функции и продолжаем 
движение по строке до ее конца.

Тест 2
Покрытие программы 100%.Рассматривается 6 случаев:
-проверка перевода в JSON и обратно пустого словоря
-проверка перевода в JSON и обратно пустого списка
-проверка перевода в JSON и обратно пустого кортежа
-проверка перевода в JSON и обратно заданного нами класса
-две проверки перевода в JSON и обратно различных типов данных

Основное 3. В программе мы реализуем класс "вектор". Для данного класса были перегруженны методы сложения векторов, умножения на число 
и на вектор (рассмотренно 2 случая, как для множителя расположенного с правой стороны, так и с левой), вычитание векторов, получение координаты
по индексу, Нахождение скалярного произведения(len), функция представления вектора в нормальном виде(__repr__), а также перегрузка всех видов 
сравнения равенств.

Тест 3 
Покрытие программы 100%.Рассматривается 6 случаев:
-некорректное создание вектора
-приведение к нормальному виду
-все операции сравнения(6 штук)
-все операции сложения,умножения,вычитания(9 штук)
-нахождение скалярного произведения
-получение координаты по индексу

Основное 4. В программе был написан декоратор. Для этого был использован класс со словарём, в котором мы будем хранить значения и сам кешевый декоратор.
При вызове функции, которая окутана в декоратор, мы будем обращаться в класс. Если значения аргументов функции будет совпадать со значениями, которые 
находятся в со, то возвращаем значение функции, которое хранится в словаре. Если же значения функции с такими аргументами в словаре не надено, то производится
вычисление значения функции, а потом в словарь добавляется функция с этими аргументами и ее значения. Для примера была рассмотрена рекурсивная функция, 
которая возвращает числа Фибоначчи.

Тест 4
Покрытие программы 100%.Рассматривается 7 случаев:
-вызов функции с некорректными значениями
-проверка на отрицательное число
-четыре теста на проверку корректности полученых значений при вызове функции с значениями от 0 до 3
-проверка на получение правильного словаря, состоящего из 7 чисел Фибоначчи

Основное 5. Продемонстрировано по ходу основных заданий. Для прохождения тестов в терминале необходимо прописать pytest (Название теста).py 

Доп. 2. Создается 2 класса, один из которых будет выступать мета-классом второго. Мета-класс выполняет роль "флага", если объект Singleton уже создан, то он вернет его,
а не будет создавать новый. Если же Singleton еще не был создан, то он создаст его и "поднимет" наш "флаг". Сам же Singleton выступает в роли класса, у 
которого может быть прописана некоторая логика. При вызыве конструктора Singleton обращение поступает к мета-классу и если объекта еще не существует, то мета-класс позволяет 
создать объект Singleton. Класс-Singleton обычно используется для того, чтобы быть уверенным, что мы обратимся только к этому объекту, и создание аналогичного невозможно.  

Доп. 3. Данное задание реализует устанавливаемый пакет со всеми тестами и заданиями программы. Для его выполнения в папке с проектами был создан файл __init__.py
Также был создан файл README.txt. и файл MANIFEST.in необходимый для прикрипления к созданному пакету файлов с расширением .txt
В моей лабораторной работе нет зависимостей, поэтому поле, в котором они должны быть указаны, остается пустым. Все скрипты для запуска задания указаны в модуле main.py. 
При создании пакета мы получаем архив, который при распаковке и получится нашим пакетом. 